## 防御性编程
### 什么叫Bug？
Bug可以定义为对于对于实现需求的代码违例
### 防御手段
 总是假设自己的代码是错误的，通过Assert去检查自己的代码错误。由于Bug的引入往往是程序员在编写代码时对于实际需求的语义缺失，所以检查本省可以赋予意义
```c
#define CHECK_INT(x, cond) panic!(concat(x, cond), "%s", cond)

## lockdep
对于死锁的检查是操作系统常常讲的一个问题，我们先介绍lock ordering
### lock ordering
 如果我们定义一个获取锁的全局顺序，这样就可以避免循环等待，但是实际中往往为锁确定一个好的顺序是困难的，同时锁可能很多。
### 一种检查
```c
struct LOCK {
 int a;
 char info;
}

#define LOCK_INIT() { \
 LOCK item; item.a = 0; item.info = __LINE__; \
} while(0)
```
这样为锁记录一个Line，如果讲所有在同一个位置获取的锁记为同一把锁，那么遍历所得获取记录，就可以知道锁是否存在一个全局序。

### Race检查
对于Race的检查可以引入编译器的帮助，在有多个线程的情况下，多个线程可以视为多个单线执行流。同时之间有一些同步原语确定一个先后关系进行连接执行流，同时在这些原语中间有一些共享变量的访问，这样就可以通过两个线程之间同一变量之间是否存在路径判断是否合法。

## canary
 为内存设立红区，牺牲一部分内存空间，这份空间中存入一些MAGIC, 这样可以快速检查溢出。这些区域可以称为红区。
 
## 简化
简单系统中可以简单实现，如一锁过长时间没有获取可以直接视为死锁。
