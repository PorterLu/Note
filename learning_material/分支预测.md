## 分支预测

### 两bit饱和计数器

![](https://raw.githubusercontent.com/PorterLu/picgo/main/two_bits_saturated_branch_predictor.png)

​	只是基于上一次的跳转结果进行预测，面对`TNTNTN`这样的序列会出现问题。于是就有了两bit饱和分支预测器，两次的分支不命中，才会从`strongly not taken`到`weakly taken`。

​	虽然计数器的种类非常多，但是事实证明两bit饱和计数器是最为坚挺的。这里的计数器是对于一条指令的，在实际过程中需要有多个计数器。

![](https://raw.githubusercontent.com/PorterLu/picgo/main/hash_two_bits_saturated_counter.png)

​	在有限个`PHT`表项时需要减少碰撞。

### 基于局部历史

​	但是如果我们将初始状态设置位弱不跳转，那么面对`TNTNTN`这样的序列的预测命中概率还是只有0。这里引入了自适应两级分支预测。使用分支历史寄存器`BHR`，寄存器中会记录上一次这条跳转指令是否命中，并使用`BHR`中的值进行索引一个`PHT`项。

![](https://raw.githubusercontent.com/PorterLu/picgo/main/BHR_predict.png)

​	同样在只有有限的表项时需要哈希。这样`BHR`会记录到分支预测的局部规律，更新到`PHT`中相应的饱和分支计数器中。

### 基于全局历史

![](https://raw.githubusercontent.com/PorterLu/picgo/main/GHR_predict.jpg)

​	有时一个跳转会和其他跳转是否发生相关，这时候全局的跳转的关系就更为重要。全局历史寄存器会保存每一条分支指令的跳转历史，这样更新`PHT`中就是对应某一个全局`branch pattern`的跳转规律。

### 竞争

​	对于局部历史和全局历史，可以使用竞争来判断选择哪一个。

![](https://raw.githubusercontent.com/PorterLu/picgo/main/CHPT.jpg)

​	基于两种历史的命中情况，`CHPT`会进行两bit技术器的更新，同时根据`CPHT`选择全局历史和还是局部历史的结果进行跳转。

### 分支地址预测

​	对于直接跳转，即加上取出指令的`size`或者固定跳转到某一个地址。这种跳转在流水线有很多多级，取出指令需要多个周期时，同时位时钟频率的考虑，这里往往也要进行预测。

​	`BTB(Branch Target Buffer)`实现时可以一个组相联的设计，一旦缺失，可以暂停流水线或者静态预测。

​	而对于间接跳转，跳转的地址地址是不确定的，对于`call`跳转的地址是确定，但是对于`return`的地址却可以有很多，因为可以在不同的地方调用函数。这样对于`return`可以使用一个`RAS(Return Address Stack)`，在`call`是对于返回地址进行记录，这样返回时就可以通过栈中记录的地址准确预测。