# RISC-V内存一致性模型

​	RISC-V手册明确了RISC-V内存一致性模型，称为"RVWMO"（RISC-V Weak Memory Order）。下面进行说明：

## 规则

### 多拷贝原子性

​	RVWMO通过global memory order定义内存访问顺序约束，对于不允许乱序的情况称为保留程序序（preserved program order, PPO)。全局序即所有并发并行执行的线程在内存系统中形成的最终内存访问顺序，各个线程对于这个全局序的观察是一致的，除了store buffer带来的”写后读“的情况。store buffer是hart的私有缓存，用于暂存要写入内存的数据这里的数据对于本hart可见，即写后再读可以读到这个写入的值，但是对于其他的hart不可见，因此双方可能观察到不一样的访问顺序，RISC-V包容这种情况。

​	为了形成一致的全局序，一个hart如果看到了另外一个hart的写，则必须所有的hart都看到了这个写，否则会出现不一致的情况，这个特性称为多拷贝原子性。

### 遵循自然的语法依赖

​	语法依赖准确的定义比较复杂，简单来讲，语法依赖就是指一条指令的原操作数与前面指令的目的操作数是同一个寄存器，前面不得出结果，后面就没法执行，这种逻辑上的约束，自然成为一种约束。

* 看寄存器名而不是值
* 不是所有指令都有目的操作数
* x0寄存器不构成依赖

```assembly
(a) ld a1, 0(s0)
(b) xor a2, a1, a1
(c) add s1, s1, a2
(d) ld a5, 0(s1)
```

​	指令(b)要执行，必须要求(a)读到a1, 指令(c)要执行必须要求(b)计算出a2的地址，指令(d)要执行必须要求指令(c)的s1计算出结果。这种指令序列之间的依赖关系形成了一个依赖链。

​	对于内存访问的操作，语法依赖按寄存器用途可以分为3类要求保证有序

* 地址依赖，前一条指令的结果是后一条指令访存的地址，相当于指针
* 数据依赖，前一条指令的结果是后一条的操作数
* 控制依赖，两条指令间存在一个依赖于第一条的分支或间接跳转指令。用C语言的if语言比拟：条件语句对后续的所有指令形成控制依赖。

```assembly
(a) lw x1, 0(x2)
(b) bne x1, x0, next
(c) next: sw x3, 0(x4)
```

实例：

```assembly
	代码1 		 	代码2				代码3			代码4
(a) lw t0, (s0)	    lw t0, (s0)		lw t0, (s0)		lw t0, (s0)
(b) sw t1, (t0)		sw t0, (t1)		sw t1, (t0)		lw t1, (t0)
(c) lw t2, (t0)		lw t2, (t1)		sw t2, (s1)		sw t2, (s1)
```

​	这四段特殊的代码范例都是前两条指令构成语法依赖，第三条指令进行相关的读或不止是否相关的写，这种流水线依赖明确是不能乱序的。

### 对于同一地址，写不超前、读CoRR、原子操作不能乱序

​	”同一地址“允许地址部分交叉重叠，规则约束的仅仅是这重叠部分。

* 写不超前。对`任何访存指令 -> po store`， store指令在全局序上不会超越前面的指令。这可以理解为如果允许后面的写乱序，则可能导致读不到应该读的值，或者后面写的值被前面写的值覆盖了。

```assembly
	Hart0				Hart1
	li t1, 1		 	li t2, 2
(a) sw t1, 0(s0) 	(d) lw a0, 0(s1)
(b)	fence w, w		(e) sw t2, 0(s1)
(c)	sw t1,0(s1)		(f) lw a1, 0(s1)
					(g)	xor t3, a1, a1
					(h) add s0, s0, t3
					(i)	lw	a2, 0(s0)
					
Outcome: a0=1, a1=2, a2=0(允许)
```

​	先看(d)和(e)的关系，它们是对同一地址的访问，因此store指令(e)在全局的顺序上就不能超越(d)。

* 读CoRR。对于同一地址的两个读，只要后一个load不到更老的值，就不约束两者的内存序，这个特性成为Coherence for Read-Read pairs。反过来说，当且仅当两个load中间没有对这一地址的写，且返回不同的值，要保持读的顺序不能乱。

上面实例的结果，说明执行序列是(f)-(i)-(a)-(c)-(d)-(e)，正是因为(e)的存在，是的同一地址的两个读(f)能读到比(d)更新的值，从而允许在内存序上超越(d)。前面说”写不超前“，那(e)怎么先写呢？硬件先把(e)存到store buffer中，(f)就可以继续执行。

```assembly
	Hart0				Hart1
	li t1, 1		(d) lw a0, 0(s1)
(a)	sw t1, 0(s0)	(e) xor t2, a0, a0
(b) fence w, w		(f) add s4, s2, t2
(c) sw, t1, 0(s1)	(g) lw	a1, 0(s4)
					(h) lw 	a2, 0(s2)
					(i)	xor t3, a2, a2
					(j) add s0, s0, t3
					(k) lw	a3, 0(s0)
```

​	执行序列是(h)-(k)-(a)-(c)-(d)-(g), (g)和(h)是对同一地址的读且读到的是同一个值，因此允许(h)及之后的指令先完成而不违反(g)、(h)之间的CoRR约束。

* 原子操作不乱序。原子指令因为含有store操作，因此当其位于程序序的后面时不会超越前面的指令。当其位于前面时，如果后面的是store指令不会乱序，如果是load指令，规范明确规定不允许乱序，主要因为为了保证原子指令的操作语言。需要注意的是，对于lr/sc原子指令对，成功的sc才代码表这个原子指令的成功执行，失败的sc不产生任何内存操作，自然也不会对内存约束产生任何贡献。

### 其他任何情况都可以乱序

​	包括原子指令，因此需要专门的指令来强制约束内存访问顺序。

## 内存序约束指令

### 1.通用指令

FENCE 用于约束常规内存和设备I/O的访问顺序，常规只推荐了5种组合

* FENCE RW,RW
* FENCE RW, W
* FENCE R, RW
* FENCE R, R
* FENCE W, W

当需要跨越内存种类明确约束访问顺序时，只能使用fence指令。特别地，访问time、cycle、mcycle控制状态寄存器(CSR)时可能还需要fence指令，因为CSRs通常为弱内存序的内存映射I/O单元，与常规内存也无必然的约束要求；在使用时用i表示CSR读，o表示CSR写。

### 2.原子指令

标准扩展A提供了原子操作指令，用于构建线程同步操作，同时提供了可选的单向内存序约束标记。

* .aq, 约束为acquire内存序，后续的不论是读还是写指令都不超前于指令执行。
* .rl, 约束为release内存序，前面的不论是读还是写指令都在本指令前完成，如：`sc.rl`。 .rl不约束后面的指令，到那时RISC-V规定如果后面的指令有aq标记，则约束其不能超越rl标记指令。
* .aqrl, 约束为顺序一致（Sequential Consistency，SC)内存序，前面的读写指令发生在本指令之前，后面的发生在本指令之后。对于lr/sc原子指令来说，sc内存约束应该采用`lr.aq/sc.aqrl`， 因为该原子指令执行的标记是成功的sc操作，sc.aqrl确保前后指令均不越界；反过来如 `lr.aqrl/sc.rl`， 其他hart可能观察到sc后的指令发生在sc之前。

### 3.专用指令

​	程序执行时有很多隐式的内存访问操作，如CPU指令预取单元取指令，内存管理单元（MMU）访问页表等，当这部分内存发生变化时，为了保证变化及时生效，也需要约束内存访问顺序，跟准确地说明各个单元进行同步的操作。这些执行机构会使用一些专门的部件，像指令缓存、TLB缓存等。

​	FENCE.I确保指令缓存的更新。当然这是只对本hart有效，如果需要传播到其他hart，那么需要通过核间中断通知其他hart。

​	SFENCE.VMA 定义为特权指令，同步页表更新。

```assembly
sfence.vma vaddr, asid

vaddr=x0, asid=x0时，作用于所有地址空间的各级页表的访问操作
vaddr=x0, asid!=x0时，作用指定地址空间的各级页表的操作
vaddr!=x0, asid=x0时，作用于所有地址空间指定虚拟地址对应的页表项访问操作
vaddr!=x0, asid!=x0时，作用于指定地址空间执行虚拟地址对应的页表项访问操作
```

主要有三种使用场景：

* 更新PMP寄存器。PMP(Physic Memory Protection)是可选的控制物理内存可访问性的每hart系统寄存器，每个访问操作都要经过PMP检查。同步指令为 `sfence.vma x0,x0`。仅发生在M模式
* 更新satp寄存器。satp是存储进程根页表信息的寄存器，可以发生在S模式或者M模式。
* 更新页表，一般发生在S模式



