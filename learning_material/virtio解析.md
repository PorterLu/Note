## virtio解析

​	`virtio`是通用虚拟化架构，在`Qemu-kvm`中的`I/O`是用`qemu`来模拟的，性能较差，用`virtio`来模拟`I/O`可以进一步提高`I/O`虚拟化的性能。

​	传统的`qemu-kvm`工作模式

1. 客户机产生`I/O`请求，被`KVM`截获
2. `kvm`处理后，将`I/O`请求放在`I/O`共享页
3. 通知`Qemu`，`I/O`已经放在`I/O`共享页
4. `Qemu`模拟代码来完成此次`I/O`，并发送给相应的设备驱动
5. 硬件完成`I/O`操作，并将结果返回给`Qemu`
6. `Qemu`将结果放在`I/O`共享页
7. `Qemu`通知`kvm`去`I/O`共享页取结果
8. `Kvm`取得结果并将结果返回给客户程序

## 虚拟化

### VMM

* 同质：虚拟机中运行与真实物理机器运行效果相同
* 资源受控：`VMM`全权控制硬件，包括资源分配回收
* 高效：为了让虚拟机性能接近真实物理机器，采取各种优化技术，最后是硬件辅助虚拟化。

### 特权指令和敏感指令

​	判断一个系统是否可以虚拟化，核心就是系统对于敏感指令的支持。如果所有的敏感指令都是特权指令，则可以虚拟化。如果无法支持所有敏感指令都能发出异常，则不是一个可虚拟化架构，如果强行虚拟化，则会存在虚拟化漏洞。

### 处理器虚拟化

​	处理器虚拟化是关键，内存虚拟化和`IO`虚拟化都依赖于处理器虚拟化。访问内存和`I/O`指令本身就是敏感指令。在硬件虚拟化没有出现之前，软件虚拟化提供了两种方案，1. 二进制代码动态翻译技术， 2. 修改客户及OS。

它们分别对应了全虚拟化和半虚拟化。

![image-20230105185504951](https://raw.githubusercontent.com/PorterLu/picgo/main/virtualization_arch.png)

#### vCPU

​	硬件虚拟化采用`vCPU`来描述虚拟`CPU`。

1. `vCPU`的创建，创建`vCPU`实际上是创建`vCPU`描述符，由于`vCPU`描述符是一个结构体，因此创建`vCPU`就是为其分配相应大小的内存。
2. `vCPU`的运行，`vCPU`创建完成后，就会被调度程序调度，调度程序根据调度算法来选择`vCPU`运行。
3. `vCPU`的退出，和进程一样，`vCPU`作为调度单位不可能永远运行，总会因为各种原因退出，例如执行了特权指令，发生了物理中断，这种退出在`VT-x`中表现为发生`VM-Exit`。对`vCPU`退出的处理是`VMM`进行`CPU`虚拟化的核心，例如模拟各种特权指令。
4. `vCPU`的再运行，`VMM`在处理完`vCPU`的退出后，会负责将`vCPU`再投入运行。

## 内存虚拟化

​	客户机能看到的都是`VMM`为客户机虚拟的物理地址空间。`VMM`需要将客户机的物理地址转化为实际的物理地址。

## IO虚拟化

​	在完全虚拟化的解决方案中，`guest VM`要使用底层`Host`资源，需要`Hypervisor`来截获所有的请求指令，来模拟这些指令的行为，这样会带来较大的性能开销。半虚拟化通过底层硬件辅助，将部分没必要虚拟化的指令通过硬件来完成，`Hypervisor`只需完成部分指令的虚拟化，要做到这一点，需要客户机进行配合，客户机完成不同设备的前端驱动程序，`Hypervisor`完成相应的后端驱动，这样两者通过某种交互机制就可以实现高效的虚拟化过程。

​	由于不同的`guest`前端设备的工作逻辑有很大相似之处，于是`virtio`提供了这样一套标准，提供了一套通用的架构来和标准接口之间进行交互。

## Intel 虚拟化

​	原先指令的虚拟化是用过陷入再模拟方式实现的，而`IA32`架构存在19条敏感指令不能通过这种方式实现，这就是典型虚拟化漏洞。`Intel`增加了虚拟机扩展，该指令集包含了十条左右新增指令来支持与虚拟机相关的操作，简称`Intel VT-x`技术。在该技术下，引入两种操作模式，根模式和非根模式。在根模式下，所有指令都可以运行，兼容原有的软件。在非根模式下，所有的敏感指令将被重新定义，使得它们不经过虚拟化就可以直接运行或者通过陷入再模拟方式进行处理。

​	

​	