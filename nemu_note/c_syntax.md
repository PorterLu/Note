## static
将辨析以下概念:1.静态全局变量，2.静态局部变量，3.全局变量，4.静态函数
1. 静态全局变量：静态全局变量的作用域在这个文件对外部不可见，并且没初始化的话会自动初始化。
2. 静态局部变量：也在全局空间存储变量，初始化一次，并且作用域只在这个函数
3. 全局变量：作用在整个项目，在其他文件用extern关键字就可以使用这个变量
4. 静态函数：静态函数只能在该文件使用

## for(int i=0;....}
注意在gcc的参数后加上 -std=c99

## #include<\*\*\*/\*\*\*>
这种include注意gcc的参数后一定要加上对库的说明，如-lpthread等等，具体什么库可以查询

## 宏
函数宏的形参列表最后的参数用省略号（...）表示即实现了变参函数。__VA_ARGS__用于在宏替换部分中，表明省略号代表什么。例如：#define PR(...) printf(__VA_ARGS__);


## 内联函数
内联函数（也可以称为编译时期展开函数），用来建议编译器将指定的函数体插入并取代每一处调用该函数的地方，从而节省了每次调用函数带来的额外时间开支。  
与宏的比较：
1. 宏调用并不执行类型检查，连正常参数也不检查，但是函数调用却要检查。
2. 内联代码的调试信息通常比扩展宏代码更有用。

## 双引号匹配
双引号匹配时总是就近匹配，一个引号总是匹配一个最近的引号变成一个双引号。

## 文件的打开方式
* r、r+，开的文件必须存在
* 带+，一定可读可写
* w打开的文件会覆盖原来的内容
* t表示文本文件，b表示二进制文件
* a表示在文件后附加内容，和w一样没有+表示只能写
* linux系统，文本模式和二进制模式没有区别；但是在windows系统，在文本模式中，打入'\n'会自动转化为'\r\n'

## fflush机制
### 铺垫
* printf默认打开的stdout标准输出流，在其上写数据。重定向可以改变打开的流，写到别的流上。
* printf作为标准IO的一部分，它是带缓冲区的
* 重定向之后缓冲区的类型从行缓冲变成了全缓冲
* exit函数在执行的时候会自动flush所有流
### 缓冲区的类型
1. 全缓冲，这是一块malloc生成的内存块，用于缓冲数据。操作磁盘的文件通常是由标准IO库进行全缓冲，在一个流上第一次执行IO操作时会调用相关的函数调用malloc生成缓冲区。全缓冲的特点就是写满了之后进行实际的IO操作。
2. 行缓冲，只有遇到换行符才进行实际的换行操作，当让还有行缓冲满了但是还没遇到一个换行符的时候。本质上还是一个全缓冲只不过带上了只要遇到换行符就fflush的特性。
### fflush特性
默认情况下，发送到stdout的输出，然后再发送到屏幕（我们也可以重定向到其他流）。同样stdin也默认映射到键盘输入，当也可以重定向到其他流。
stdout默认情况下是行缓冲的，意味着stdout在遇到一个换行符之前，不会立即输出。
